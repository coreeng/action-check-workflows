{"version":3,"sources":["../src/index.ts","../src/changed-files.ts","../src/workflows.ts","../src/patterns.ts"],"sourcesContent":["import * as core from '@actions/core';\nimport * as github from '@actions/github';\nimport { getChangedFiles } from './changed-files';\nimport { assessWorkflows } from './workflows';\nimport type { EventContext, GitHubRepository } from './types';\n\ntype UnknownRecord = Record<string, unknown>;\n\nfunction isRecord(value: unknown): value is UnknownRecord {\n  return typeof value === 'object' && value !== null;\n}\n\nfunction getNestedValue(source: unknown, path: readonly string[]): unknown {\n  let current: unknown = source;\n  for (const segment of path) {\n    if (!isRecord(current)) {\n      return undefined;\n    }\n    current = current[segment];\n  }\n  return current;\n}\n\nfunction getNestedString(source: unknown, path: readonly string[]): string | null {\n  const value = getNestedValue(source, path);\n  return typeof value === 'string' ? value : null;\n}\n\nexport async function run(): Promise<void> {\n  const token = core.getInput('github-token', { required: true });\n  const repoInput = core.getInput('repository');\n  const baseRefInput = core.getInput('base-ref');\n  const headRefInput = core.getInput('head-ref');\n  const workflowRefInput = core.getInput('workflow-ref');\n  const eventNameInput = core.getInput('event-name');\n  const refInput = core.getInput('ref');\n  const baseBranchInput = core.getInput('base-branch');\n  const headBranchInput = core.getInput('head-branch');\n  const actionInput = core.getInput('pull-request-action');\n  const diffStrategyInput = (core.getInput('diff-strategy') || 'auto').toLowerCase();\n\n  const context = github.context;\n\n  const repository = resolveRepository(repoInput, context);\n  const baseRef = resolveBaseRef(baseRefInput, context);\n  const headRef = resolveHeadRef(headRefInput, context);\n  const workflowRef = workflowRefInput ?? headRef;\n\n  if (!baseRef || !headRef) {\n    throw new Error('Both `base-ref` and `head-ref` must be provided or derivable from the event context.');\n  }\n\n  if (!workflowRef) {\n    throw new Error('Unable to determine the ref to inspect workflows against.');\n  }\n\n  const diffStrategy = resolveDiffStrategy(diffStrategyInput, context.eventName ?? '');\n\n  const octokit = github.getOctokit(token);\n\n  const changedFiles = await getChangedFiles({\n    octokit,\n    repository,\n    baseRef,\n    headRef,\n    diffStrategy\n  });\n\n  const eventContext: EventContext = buildEventContext({\n    context,\n    refOverride: refInput,\n    eventNameOverride: eventNameInput,\n    baseBranchOverride: baseBranchInput,\n    headBranchOverride: headBranchInput,\n    actionOverride: actionInput\n  });\n\n  const assessments = await assessWorkflows({\n    octokit,\n    repository,\n    ref: workflowRef,\n    changedFiles: changedFiles.files,\n    context: eventContext\n  });\n\n  const triggeredWorkflows = assessments.filter((assessment) => assessment.autoTriggered);\n\n  const report = {\n    repository,\n    baseRef,\n    headRef,\n    workflowRef,\n    diffStrategy,\n    changedFiles,\n    workflows: assessments\n  };\n\n  core.setOutput('changed-files', JSON.stringify(changedFiles.files));\n  core.setOutput('triggered-workflows', JSON.stringify(triggeredWorkflows));\n  core.setOutput('report', JSON.stringify(report));\n\n  await writeSummary({\n    assessments,\n    changedFilesCount: changedFiles.files.length,\n    triggeredCount: triggeredWorkflows.length\n  });\n}\n\ninterface EventContextOptions {\n  context: typeof github.context;\n  refOverride?: string;\n  eventNameOverride?: string;\n  baseBranchOverride?: string;\n  headBranchOverride?: string;\n  actionOverride?: string;\n}\n\nfunction buildEventContext(options: EventContextOptions): EventContext {\n  const { context, refOverride, eventNameOverride, baseBranchOverride, headBranchOverride, actionOverride } = options;\n  const payload = context.payload as unknown;\n\n  const ref = refOverride ?? context.ref ?? null;\n  const eventName = eventNameOverride ?? context.eventName ?? 'push';\n  const baseBranch =\n    baseBranchOverride ??\n    getNestedString(payload, ['pull_request', 'base', 'ref']) ??\n    getNestedString(payload, ['merge_group', 'base_ref']) ??\n    getNestedString(payload, ['workflow_run', 'head_branch']) ??\n    null;\n  const headBranch =\n    headBranchOverride ??\n    getNestedString(payload, ['pull_request', 'head', 'ref']) ??\n    getNestedString(payload, ['merge_group', 'head_ref']) ??\n    null;\n  const actionValue = actionOverride ?? getNestedString(payload, ['action']);\n  const action = actionValue ?? undefined;\n\n  const refName = ref === null ? null : ref.replace(/^refs\\//, '');\n  const branchName =\n    ref === null ? null : ref.startsWith('refs/heads/') ? ref.replace(/^refs\\/heads\\//, '') : ref;\n  const tagName = ref !== null && ref.startsWith('refs/tags/') ? ref.replace(/^refs\\/tags\\//, '') : null;\n\n  return {\n    ref,\n    refName,\n    branchName,\n    tagName,\n    baseBranch,\n    headBranch,\n    eventName,\n    action\n  };\n}\n\nfunction resolveRepository(repoInput: string, context: typeof github.context): GitHubRepository {\n  if (repoInput) {\n    const [owner, repo] = repoInput.split('/');\n    if (!owner || !repo) {\n      throw new Error('`repository` input must be in the form \"owner/repo\".');\n    }\n    return { owner, repo };\n  }\n\n  if (!context.repo?.owner || !context.repo?.repo) {\n    throw new Error('Unable to determine repository from context.');\n  }\n\n  return { owner: context.repo.owner, repo: context.repo.repo };\n}\n\nfunction resolveBaseRef(baseRefInput: string, context: typeof github.context): string | null {\n  if (baseRefInput) {\n    return baseRefInput;\n  }\n\n  const payload = context.payload as unknown;\n\n  if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {\n    return getNestedString(payload, ['pull_request', 'base', 'sha']);\n  }\n\n  if (context.eventName === 'push') {\n    return getNestedString(payload, ['before']);\n  }\n\n  return null;\n}\n\nfunction resolveHeadRef(headRefInput: string, context: typeof github.context): string | null {\n  if (headRefInput) {\n    return headRefInput;\n  }\n\n  const payload = context.payload as unknown;\n\n  if (context.eventName === 'pull_request' || context.eventName === 'pull_request_target') {\n    return getNestedString(payload, ['pull_request', 'head', 'sha']);\n  }\n\n  const sha = context.sha;\n  return sha ?? null;\n}\n\nfunction resolveDiffStrategy(strategy: string, eventName: string): 'two-dot' | 'three-dot' {\n  if (strategy === 'two-dot' || strategy === 'three-dot') {\n    return strategy;\n  }\n\n  if (eventName === 'push') {\n    return 'two-dot';\n  }\n\n  return 'three-dot';\n}\n\nasync function writeSummary(options: {\n  assessments: Awaited<ReturnType<typeof assessWorkflows>>;\n  changedFilesCount: number;\n  triggeredCount: number;\n}): Promise<void> {\n  const { assessments, changedFilesCount, triggeredCount } = options;\n\n  core.summary.addHeading('Workflow Trigger Assessment', 2);\n  core.summary.addRaw(`Changed files analysed: **${changedFilesCount}**\\n`);\n  core.summary.addRaw(`Workflows automatically triggered: **${triggeredCount}**\\n\\n`);\n\n  if (assessments.length) {\n    core.summary.addTable([\n      ['Workflow', 'Triggered', 'Reasons / Matched Files'],\n      ...assessments.map((assessment) => [\n        assessment.name,\n        assessment.autoTriggered ? 'Yes' : 'No',\n        assessment.triggers\n          .map((trigger) => {\n            const status = trigger.matches ? '✅' : '❌';\n            if (trigger.matches) {\n              return `${status} ${trigger.event}`;\n            }\n            const reason = trigger.reasons.join('; ') || 'Not triggered';\n            return `${status} ${trigger.event}: ${reason}`;\n          })\n          .join('\\n')\n      ])\n    ]);\n  }\n\n  await core.summary.write();\n}\n\nif (typeof require !== 'undefined' && typeof module !== 'undefined' && require.main === module) {\n  run().catch((error) => {\n    if (error instanceof Error) {\n      core.setFailed(error.message);\n    } else {\n      core.setFailed('Unknown error occurred.');\n    }\n  });\n}\n","import * as core from '@actions/core';\nimport { getExecOutput } from '@actions/exec';\nimport type { GitHub } from '@actions/github/lib/utils';\nimport { ChangedFile, GitHubRepository } from './types';\n\ntype OctokitClient = InstanceType<typeof GitHub>;\n\ninterface CompareFilePayload {\n  filename?: string;\n  status?: string;\n  previous_filename?: string | null;\n}\n\ninterface CompareCommitsPayload {\n  files?: CompareFilePayload[] | null;\n  total_files?: number | null;\n}\n\nexport interface ChangedFilesOptions {\n  octokit: OctokitClient;\n  repository: GitHubRepository;\n  baseRef: string;\n  headRef: string;\n  diffStrategy?: 'two-dot' | 'three-dot';\n}\n\nexport interface ChangedFilesResult {\n  files: ChangedFile[];\n  source: 'api' | 'git';\n  truncated: boolean;\n}\n\nexport async function getChangedFiles(options: ChangedFilesOptions): Promise<ChangedFilesResult> {\n  const { octokit, repository, baseRef, headRef, diffStrategy = 'three-dot' } = options;\n\n  const basehead = diffStrategy === 'two-dot' ? `${baseRef}..${headRef}` : `${baseRef}...${headRef}`;\n  const compareResponse = await octokit.rest.repos.compareCommitsWithBasehead({\n    owner: repository.owner,\n    repo: repository.repo,\n    basehead,\n    per_page: 100\n  });\n\n  const payload = normalizeCompareResponse(compareResponse.data);\n  const files = mapCompareResponse(payload);\n  const totalFiles = typeof payload.total_files === 'number' ? payload.total_files : files.length;\n  const truncated = totalFiles > files.length || files.length >= 300;\n\n  if (!truncated) {\n    return {\n      files,\n      source: 'api',\n      truncated: false\n    };\n  }\n\n  core.info(\n    `Compare API returned ${files.length} files (possibly truncated). Falling back to local git diff for complete list.`\n  );\n\n  const fallbackFiles = await getFilesFromGit(baseRef, headRef, diffStrategy);\n\n  return {\n    files: fallbackFiles,\n    source: 'git',\n    truncated: false\n  };\n}\n\nfunction mapCompareResponse(data: CompareCommitsPayload): ChangedFile[] {\n  const entries = Array.isArray(data.files) ? data.files : [];\n\n  const results: ChangedFile[] = [];\n\n  for (const entry of entries) {\n    if (!isCompareFile(entry)) {\n      continue;\n    }\n\n    const status = normalizeStatus(entry.status);\n    const path = normalizePath(entry.filename);\n    const previousPath = entry.previous_filename ? normalizePath(entry.previous_filename) : undefined;\n\n    results.push({\n      path,\n      status,\n      previousPath\n    });\n  }\n\n  return results;\n}\n\nfunction normalizeCompareResponse(data: unknown): CompareCommitsPayload {\n  if (typeof data !== 'object' || data === null) {\n    return {};\n  }\n\n  const record = data as { files?: unknown; total_files?: unknown };\n  return {\n    files: Array.isArray(record.files) ? (record.files as CompareFilePayload[]) : undefined,\n    total_files: typeof record.total_files === 'number' ? record.total_files : null\n  };\n}\n\nasync function getFilesFromGit(\n  baseRef: string,\n  headRef: string,\n  diffStrategy: 'two-dot' | 'three-dot'\n): Promise<ChangedFile[]> {\n  const range = diffStrategy === 'two-dot' ? `${baseRef}..${headRef}` : `${baseRef}...${headRef}`;\n\n  const args = ['diff', '--name-status', range];\n  const { stdout } = await getExecOutput('git', args, { silent: true });\n\n  const files: ChangedFile[] = [];\n\n  for (const line of stdout.trim().split('\\n')) {\n    if (!line) continue;\n\n    const [statusToken, ...rest] = line.split('\\t');\n    if (!statusToken) continue;\n\n    if (statusToken.startsWith('R')) {\n      const [previousPath, path] = rest;\n      if (!previousPath || !path) {\n        continue;\n      }\n\n      files.push({\n        path: normalizePath(path),\n        previousPath: normalizePath(previousPath),\n        status: 'renamed'\n      });\n      continue;\n    }\n\n    const [path] = rest;\n    if (!path) {\n      continue;\n    }\n\n    files.push({\n      path: normalizePath(path),\n      status: normalizeStatus(statusToken)\n    });\n  }\n\n  return files;\n}\n\nfunction isCompareFile(file: unknown): file is Required<Pick<CompareFilePayload, 'filename'>> & CompareFilePayload {\n  return (\n    typeof file === 'object' &&\n    file !== null &&\n    typeof (file as { filename?: unknown }).filename === 'string'\n  );\n}\n\nfunction normalizeStatus(status: string | undefined): ChangedFile['status'] {\n  switch (status) {\n    case 'added':\n    case 'A':\n      return 'added';\n    case 'modified':\n    case 'M':\n      return 'modified';\n    case 'removed':\n    case 'D':\n      return 'removed';\n    case 'renamed':\n    case 'R':\n      return 'renamed';\n    default:\n      return 'modified';\n  }\n}\n\nfunction normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n","import * as core from '@actions/core';\nimport type { GitHub } from '@actions/github/lib/utils';\nimport {\n  NoOperationTraceWriter,\n  convertWorkflowTemplate,\n  parseWorkflow\n} from '@actions/workflow-parser';\nimport { Buffer } from 'node:buffer';\nimport {\n  ChangedFile,\n  EventContext,\n  GitHubRepository,\n  WorkflowAssessment,\n  WorkflowTriggerEvaluation\n} from './types';\nimport {\n  evaluateBranchFilters,\n  evaluatePathFilters,\n  evaluateTagFilters,\n  evaluateTypesFilter\n} from './patterns';\n\ntype OctokitClient = InstanceType<typeof GitHub>;\ntype WorkflowTemplate = Awaited<ReturnType<typeof convertWorkflowTemplate>>;\n\nexport interface LoadWorkflowsOptions {\n  octokit: OctokitClient;\n  repository: GitHubRepository;\n  ref: string;\n}\n\nexport interface AssessWorkflowsOptions extends LoadWorkflowsOptions {\n  changedFiles: ChangedFile[];\n  context: EventContext;\n}\n\ninterface WorkflowFile {\n  name: string;\n  path: string;\n  content: string;\n}\n\ninterface DirectoryEntry {\n  type?: string;\n  name?: string;\n  path?: string;\n}\n\ninterface FileEntry extends DirectoryEntry {\n  content?: string | null;\n  encoding?: string | null;\n}\n\nexport async function assessWorkflows(options: AssessWorkflowsOptions): Promise<WorkflowAssessment[]> {\n  const { octokit, repository, ref, changedFiles, context } = options;\n\n  const workflowFiles = await loadWorkflowFiles({ octokit, repository, ref });\n\n  const pathSet = new Set<string>();\n  for (const file of changedFiles) {\n    pathSet.add(normalizePath(file.path));\n    if (file.previousPath) {\n      pathSet.add(normalizePath(file.previousPath));\n    }\n  }\n  const changedPaths = Array.from(pathSet);\n\n  const assessments: WorkflowAssessment[] = [];\n\n  for (const file of workflowFiles) {\n    const { template, errors } = await parseWorkflowFile(file);\n\n    if (!template) {\n      assessments.push({\n        name: file.name,\n        path: file.path,\n        triggers: [],\n        autoTriggered: false,\n        errors\n      });\n      continue;\n    }\n\n    const triggers = evaluateWorkflowTriggers(template, changedPaths, context);\n    const autoTriggered = triggers.some((trigger) => trigger.matches);\n\n    assessments.push({\n      name: getTemplateName(template, file.name),\n      path: file.path,\n      triggers,\n      autoTriggered,\n      errors\n    });\n  }\n\n  return assessments;\n}\n\nasync function loadWorkflowFiles(options: LoadWorkflowsOptions): Promise<WorkflowFile[]> {\n  const { octokit, repository, ref } = options;\n  const files: WorkflowFile[] = [];\n\n  await traverse('.github/workflows');\n  return files;\n\n  async function traverse(path: string): Promise<void> {\n    try {\n      const response = await octokit.rest.repos.getContent({\n        owner: repository.owner,\n        repo: repository.repo,\n        path,\n        ref\n      });\n      const data = response.data as unknown;\n\n      if (Array.isArray(data)) {\n        for (const entry of data) {\n          if (isFileEntry(entry) && isWorkflowFile(entry.name)) {\n            const fileResponse = await octokit.rest.repos.getContent({\n              owner: repository.owner,\n              repo: repository.repo,\n              path: entry.path,\n              ref\n            });\n            const resolved = fileResponse.data as unknown;\n            if (!isFileEntry(resolved) || typeof resolved.content !== 'string') {\n              continue;\n            }\n\n            files.push({\n              name: entry.name,\n              path: entry.path,\n              content: decodeContent(resolved.content, resolved.encoding)\n            });\n          } else if (isDirectoryEntry(entry)) {\n            await traverse(entry.path);\n          }\n        }\n      } else if (isFileEntry(data) && typeof data.content === 'string' && isWorkflowFile(data.name)) {\n        files.push({\n          name: data.name,\n          path: data.path,\n          content: decodeContent(data.content, data.encoding)\n        });\n      }\n    } catch (error) {\n      if (isNotFoundError(error)) {\n        core.info(`No workflows found at ${path} for ref ${ref}.`);\n        return;\n      }\n\n      throw error;\n    }\n  }\n}\n\nfunction isWorkflowFile(filename: string): boolean {\n  return filename.endsWith('.yml') || filename.endsWith('.yaml');\n}\n\nfunction decodeContent(content: string, encoding?: string | null): string {\n  if (encoding !== 'base64') {\n    return content;\n  }\n\n  return Buffer.from(content, 'base64').toString('utf8');\n}\n\nasync function parseWorkflowFile(file: WorkflowFile): Promise<{\n  template: WorkflowTemplate | undefined;\n  errors: string[];\n}> {\n  const trace = new NoOperationTraceWriter();\n  const result = parseWorkflow({ name: file.name, content: file.content }, trace);\n\n  if (!result.value) {\n    return {\n      template: undefined,\n      errors: ['Workflow failed to parse.']\n    };\n  }\n\n  const template = await convertWorkflowTemplate(result.context, result.value);\n  const parseErrors = result.context.errors.getErrors().map((err) => err.message);\n  const templateErrors = template.errors?.map((err) => err.Message) ?? [];\n\n  return {\n    template,\n    errors: [...parseErrors, ...templateErrors]\n  };\n}\n\nfunction getTemplateName(template: WorkflowTemplate, fallback: string): string {\n  const nameToken = (template as { name?: { value?: unknown } }).name;\n  const value = nameToken && typeof nameToken === 'object' ? (nameToken as { value?: unknown }).value : undefined;\n  return typeof value === 'string' && value.length > 0 ? value : fallback;\n}\n\nfunction isDirectoryEntry(entry: unknown): entry is Required<Pick<DirectoryEntry, 'path'>> & DirectoryEntry {\n  return (\n    typeof entry === 'object' &&\n    entry !== null &&\n    (entry as DirectoryEntry).type === 'dir' &&\n    typeof (entry as DirectoryEntry).path === 'string'\n  );\n}\n\nfunction isFileEntry(entry: unknown): entry is Required<Pick<FileEntry, 'name' | 'path'>> & FileEntry {\n  return (\n    typeof entry === 'object' &&\n    entry !== null &&\n    (entry as DirectoryEntry).type === 'file' &&\n    typeof (entry as DirectoryEntry).name === 'string' &&\n    typeof (entry as DirectoryEntry).path === 'string'\n  );\n}\n\nexport function evaluateWorkflowTriggers(\n  template: WorkflowTemplate,\n  changedPaths: string[],\n  context: EventContext\n): WorkflowTriggerEvaluation[] {\n  const triggers: WorkflowTriggerEvaluation[] = [];\n\n  if (!changedPaths.length) {\n    return [\n      {\n        event: 'unknown',\n        matches: false,\n        reasons: ['No changed files were provided for evaluation.'],\n        matchedFiles: [],\n        evaluatedFilters: {}\n      }\n    ];\n  }\n\n  const events = (template as { events?: Record<string, unknown> }).events ?? {};\n\n  for (const [eventName, config] of Object.entries(events)) {\n    switch (eventName) {\n      case 'push':\n        triggers.push(evaluatePushEvent(config, changedPaths, context));\n        break;\n      case 'pull_request':\n        triggers.push(evaluatePullRequestEvent('pull_request', config, changedPaths, context));\n        break;\n      case 'pull_request_target':\n        triggers.push(evaluatePullRequestEvent('pull_request_target', config, changedPaths, context));\n        break;\n      case 'merge_group':\n        triggers.push(evaluateMergeGroupEvent(config, changedPaths, context));\n        break;\n      case 'workflow_dispatch':\n        triggers.push(manualTriggerEvaluation(eventName));\n        break;\n      case 'workflow_call':\n        triggers.push(externalTriggerEvaluation(eventName, 'Triggered by other workflows'));\n        break;\n      default:\n        triggers.push(genericTriggerEvaluation(eventName));\n        break;\n    }\n  }\n\n  if (triggers.length === 0) {\n    triggers.push({\n      event: 'none',\n      matches: false,\n      reasons: ['Workflow does not define any triggerable events.'],\n      matchedFiles: [],\n      evaluatedFilters: {}\n    });\n  }\n\n  return triggers;\n}\n\nfunction evaluatePushEvent(\n  config: unknown,\n  changedPaths: string[],\n  context: EventContext\n): WorkflowTriggerEvaluation {\n  const pushConfig = (config ?? {}) as Record<string, unknown>;\n  const reasons: string[] = [];\n  const evaluatedFilters: WorkflowTriggerEvaluation['evaluatedFilters'] = {};\n  let matches = true;\n\n  const branchFilters = {\n    includes: extractStringArray(pushConfig.branches),\n    excludes: extractStringArray(pushConfig['branches-ignore'])\n  };\n  const tagFilters = {\n    includes: extractStringArray(pushConfig.tags),\n    excludes: extractStringArray(pushConfig['tags-ignore'])\n  };\n  const pathFilters = {\n    includes: extractStringArray(pushConfig.paths),\n    excludes: extractStringArray(pushConfig['paths-ignore'])\n  };\n\n  const branchName = context.branchName;\n  const tagName = context.tagName;\n\n  if (branchFilters.includes.length || branchFilters.excludes.length) {\n    evaluatedFilters.branches = true;\n    const branchResult = evaluateBranchFilters(branchName, branchFilters.includes, branchFilters.excludes);\n    if (!branchResult.matches) {\n      matches = false;\n      reasons.push(branchResult.reason ?? 'Branch filter did not match.');\n    }\n  }\n\n  if (tagName) {\n    evaluatedFilters.tags = Boolean(tagFilters.includes.length || tagFilters.excludes.length);\n    if (evaluatedFilters.tags) {\n      const tagResult = evaluateTagFilters(tagName, tagFilters.includes, tagFilters.excludes);\n      if (!tagResult.matches) {\n        matches = false;\n        reasons.push(tagResult.reason ?? 'Tag filter did not match.');\n      }\n    }\n  }\n\n  if (pathFilters.includes.length || pathFilters.excludes.length) {\n    evaluatedFilters.paths = true;\n  }\n\n  const pathResult = evaluatePathFilters(changedPaths, pathFilters.includes, pathFilters.excludes);\n  if (!pathResult.matches) {\n    matches = false;\n    reasons.push(...pathResult.reasons);\n  }\n\n  return {\n    event: 'push',\n    matches,\n    reasons,\n    matchedFiles: pathResult.matchedFiles,\n    evaluatedFilters\n  };\n}\n\nfunction evaluatePullRequestEvent(\n  eventName: 'pull_request' | 'pull_request_target',\n  config: unknown,\n  changedPaths: string[],\n  context: EventContext\n): WorkflowTriggerEvaluation {\n  const prConfig = (config ?? {}) as Record<string, unknown>;\n  const reasons: string[] = [];\n  const evaluatedFilters: WorkflowTriggerEvaluation['evaluatedFilters'] = {};\n  let matches = true;\n\n  const branchFilters = {\n    includes: extractStringArray(prConfig.branches),\n    excludes: extractStringArray(prConfig['branches-ignore'])\n  };\n  const pathFilters = {\n    includes: extractStringArray(prConfig.paths),\n    excludes: extractStringArray(prConfig['paths-ignore'])\n  };\n  const typeFilters = extractStringArray(prConfig.types);\n\n  if (branchFilters.includes.length || branchFilters.excludes.length) {\n    evaluatedFilters.branches = true;\n    const branchResult = evaluateBranchFilters(context.baseBranch, branchFilters.includes, branchFilters.excludes);\n    if (!branchResult.matches) {\n      matches = false;\n      reasons.push(branchResult.reason ?? 'Base branch did not match filters.');\n    }\n  }\n\n  if (pathFilters.includes.length || pathFilters.excludes.length) {\n    evaluatedFilters.paths = true;\n  }\n\n  const pathResult = evaluatePathFilters(changedPaths, pathFilters.includes, pathFilters.excludes);\n  if (!pathResult.matches) {\n    matches = false;\n    reasons.push(...pathResult.reasons);\n  }\n\n  if (typeFilters.length) {\n    evaluatedFilters.types = true;\n    const typesResult = evaluateTypesFilter(context.action, typeFilters);\n    if (!typesResult.matches) {\n      matches = false;\n      reasons.push(typesResult.reason ?? '`types` filter did not include this event action.');\n    }\n  }\n\n  return {\n    event: eventName,\n    matches,\n    reasons,\n    matchedFiles: pathResult.matchedFiles,\n    evaluatedFilters\n  };\n}\n\nfunction evaluateMergeGroupEvent(\n  config: unknown,\n  _changedPaths: string[],\n  context: EventContext\n): WorkflowTriggerEvaluation {\n  const mgConfig = (config ?? {}) as Record<string, unknown>;\n  const reasons: string[] = [];\n  const typeFilters = extractStringArray(mgConfig.types);\n  let matches = true;\n\n  if (typeFilters.length) {\n    const typesResult = evaluateTypesFilter(context.action, typeFilters);\n    if (!typesResult.matches) {\n      matches = false;\n      reasons.push(typesResult.reason ?? '`types` filter did not include this event action.');\n    }\n  }\n\n  return {\n    event: 'merge_group',\n    matches,\n    reasons,\n    matchedFiles: [],\n    evaluatedFilters: {\n      types: Boolean(typeFilters.length)\n    }\n  };\n}\n\nfunction manualTriggerEvaluation(event: string): WorkflowTriggerEvaluation {\n  return {\n    event,\n    matches: false,\n    reasons: ['Event requires manual invocation and does not respond to file changes.'],\n    matchedFiles: [],\n    evaluatedFilters: {}\n  };\n}\n\nfunction externalTriggerEvaluation(event: string, explanation: string): WorkflowTriggerEvaluation {\n  return {\n    event,\n    matches: false,\n    reasons: [explanation],\n    matchedFiles: [],\n    evaluatedFilters: {}\n  };\n}\n\nfunction genericTriggerEvaluation(event: string): WorkflowTriggerEvaluation {\n  return {\n    event,\n    matches: false,\n    reasons: ['Event runs independently of repository file changes.'],\n    matchedFiles: [],\n    evaluatedFilters: {}\n  };\n}\n\nfunction extractStringArray(value: unknown): string[] {\n  if (!value) {\n    return [];\n  }\n\n  if (Array.isArray(value)) {\n    return value.filter((item): item is string => typeof item === 'string');\n  }\n\n  if (typeof value === 'string') {\n    return [value];\n  }\n\n  return [];\n}\n\nfunction normalizePath(path: string): string {\n  return path.replace(/\\\\/g, '/');\n}\n\nfunction isNotFoundError(error: unknown): boolean {\n  return Boolean(\n    typeof error === 'object' &&\n      error !== null &&\n      'status' in error &&\n      (error as { status: number }).status === 404\n  );\n}\n","import picomatch, { Matcher } from 'picomatch';\n\nconst PICOMATCH_OPTIONS = {\n  dot: true,\n  posixSlashes: true,\n  nocase: false\n} as const;\n\ninterface CompiledPattern {\n  pattern: string;\n  negate: boolean;\n  matcher: Matcher;\n}\n\nfunction compilePattern(pattern: string): CompiledPattern {\n  const negate = pattern.startsWith('!');\n  const source = negate ? pattern.slice(1) : pattern;\n  return {\n    pattern,\n    negate,\n    matcher: picomatch(source, PICOMATCH_OPTIONS)\n  };\n}\n\nexport function compilePatterns(patterns: readonly string[] = []): CompiledPattern[] {\n  return patterns\n    .filter((pattern): pattern is string => pattern.length > 0)\n    .map((pattern) => compilePattern(pattern));\n}\n\nexport function matchesCompiled(value: string, compiled: CompiledPattern[]): boolean {\n  if (compiled.length === 0) {\n    return false;\n  }\n\n  let matched = false;\n  for (const pattern of compiled) {\n    if (pattern.matcher(value)) {\n      matched = pattern.negate ? false : true;\n    }\n  }\n\n  return matched;\n}\n\nexport function evaluatePathFilters(\n  files: readonly string[],\n  includes: readonly string[] | undefined,\n  excludes: readonly string[] | undefined\n): {\n  matches: boolean;\n  matchedFiles: string[];\n  reasons: string[];\n} {\n  const reasons: string[] = [];\n  let considered = [...files];\n\n  if (includes?.length) {\n    const compiledIncludes = compilePatterns(includes);\n    const included = considered.filter((file) => matchesCompiled(file, compiledIncludes));\n\n    if (included.length === 0) {\n      reasons.push('No changed files satisfied `paths` filter.');\n      return {\n        matches: false,\n        matchedFiles: [],\n        reasons\n      };\n    }\n\n    considered = included;\n  }\n\n  if (excludes?.length) {\n    const compiledExcludes = compilePatterns(excludes);\n    const ignored = new Set<string>();\n\n    for (const file of considered) {\n      if (matchesCompiled(file, compiledExcludes)) {\n        ignored.add(file);\n      }\n    }\n\n    if (ignored.size === considered.length) {\n      reasons.push('All matching files were ignored by `paths-ignore` filter.');\n      return {\n        matches: false,\n        matchedFiles: [],\n        reasons\n      };\n    }\n\n    considered = considered.filter((file) => !ignored.has(file));\n  }\n\n  return {\n    matches: considered.length > 0,\n    matchedFiles: considered,\n    reasons\n  };\n}\n\nexport function evaluateBranchFilters(\n  branch: string | null,\n  includes: readonly string[] | undefined,\n  excludes: readonly string[] | undefined\n): {\n  matches: boolean;\n  reason?: string;\n} {\n  if (!branch) {\n    return {\n      matches: false,\n      reason: 'Branch information unavailable to evaluate filters.'\n    };\n  }\n\n  if (includes?.length) {\n    const compiledIncludes = compilePatterns(includes);\n    if (!matchesCompiled(branch, compiledIncludes)) {\n      return {\n        matches: false,\n        reason: `Branch \"${branch}\" did not satisfy \\`branches\\` filter.`\n      };\n    }\n  }\n\n  if (excludes?.length) {\n    const compiledExcludes = compilePatterns(excludes);\n    if (matchesCompiled(branch, compiledExcludes)) {\n      return {\n        matches: false,\n        reason: `Branch \"${branch}\" was excluded by \\`branches-ignore\\` filter.`\n      };\n    }\n  }\n\n  return { matches: true };\n}\n\nexport function evaluateTagFilters(\n  tag: string | null,\n  includes: readonly string[] | undefined,\n  excludes: readonly string[] | undefined\n): {\n  matches: boolean;\n  reason?: string;\n} {\n  if (!tag) {\n    return {\n      matches: false,\n      reason: 'Tag information unavailable to evaluate filters.'\n    };\n  }\n\n  if (includes?.length) {\n    const compiledIncludes = compilePatterns(includes);\n    if (!matchesCompiled(tag, compiledIncludes)) {\n      return {\n        matches: false,\n        reason: `Tag \"${tag}\" did not satisfy \\`tags\\` filter.`\n      };\n    }\n  }\n\n  if (excludes?.length) {\n    const compiledExcludes = compilePatterns(excludes);\n    if (matchesCompiled(tag, compiledExcludes)) {\n      return {\n        matches: false,\n        reason: `Tag \"${tag}\" was excluded by \\`tags-ignore\\` filter.`\n      };\n    }\n  }\n\n  return { matches: true };\n}\n\nexport function evaluateTypesFilter(\n  actualType: string | undefined,\n  allowedTypes: readonly string[] | undefined\n): {\n  matches: boolean;\n  reason?: string;\n} {\n  if (!allowedTypes?.length) {\n    return { matches: true };\n  }\n\n  if (!actualType) {\n    return {\n      matches: false,\n      reason: 'Event type information unavailable to evaluate `types`.'\n    };\n  }\n\n  const compiled = compilePatterns(allowedTypes);\n  if (!matchesCompiled(actualType, compiled)) {\n    return {\n      matches: false,\n      reason: `Event type \"${actualType}\" did not satisfy configured \\`types\\`.`\n    };\n  }\n\n  return { matches: true };\n}\n"],"mappings":"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","names":["core","path","core","picomatch","context","normalizePath","context"]}